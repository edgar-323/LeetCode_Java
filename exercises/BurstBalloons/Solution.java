class Solution {
    public int maxCoins(int[] nums) {
        return Solution1.newSolver(nums).solve();
    }

    static class Solution1 {
        // Thoughts:
        // This is a very tricky problem.
        // Suppose you are interested in nums[i:j].
        // And suppose you decide to pop balloon k (i <= k <= j).
        // Then, you acquire coins(k-1, k, k+1) but your problem
        // structure changes because now you removed balloon k
        // from nums[i:j], so the next problem has to work on
        //      nums[i:(k-1)], nums[(k+1):j]  // Exclude nums[k].
        //
        // Recreating the array nums[i:j] would take O(j-i) time and space!
        // Now, we would do that for each value of k (i <= k <= j) so we'd
        // have a total runtime of O((j - i)^2).
        // We wouldn't even be able to have a cache on (i, j) because the
        // list it represents is not completely dictated by these endpoints.
        // So, this easily an exponential approach. Nasty!
        //
        // Let's rethink our approach.
        // Above, it is difficult to calculate a solution where we can apply
        // divide & conquer because of the fact that the nums[i:k] and nums[k:j]
        // are NOT independent! This is because after bursting nums[k], we would
        // still need to know what the balloon configuration would be at position k!
        //
        // What if, we asked:
        // Within nums[i:j], which balloon will burst LAST?
        // What is the benefit of this approach?
        // Suppose that nums[k] were to burst LAST.
        // Then we know that the number of coins generated by finally bursting
        // balloon k will be equal to nums[i-1] * nums[k] * nums[j+1].
        // This is because, by definition, only nums[k] will be left and so its
        // resulting points will be calculated by multiplying nums[k] with its
        // bordering elements.

        private final int N;
        private final int[] nums;
        private final Integer[][] cache;

        static Solution1 newSolver(int[] nums) {
            return new Solution1(nums);
        }

        int solve() {
            return solve(0, N-1);
        }

        int solve(int i, int j) {
            if (i > j) {
                // No coins from an empty subsequence.
                return 0;
            }

            if (cache[i][j] != null) {
                return cache[i][j];
            }

            int maximumCoins = 0;
            for (int k = i; k <= j; k++) {
                maximumCoins = Math.max(
                        maximumCoins,
                        // Balloon k will be the LAST to burst.
                        calculateNumCoins(i, j, k) + solve(i, k-1) + solve(k+1, j));
            }

            cache[i][j] = maximumCoins;
            return maximumCoins;
        }

        int calculateNumCoins(int i, int j, int k) {
            return nums[k] * (i > 0 ? nums[i-1] : 1) * (j < N-1 ? nums[j+1] : 1);
        }

        Solution1(int[] nums) {
            this.nums = nums;
            N = nums.length;

           cache = new Integer[N][N];
           for (int i = 0; i < N; i++) {
               for (int j = 0; j < N; j++) {
                   cache[i][j] = null;
               }
           }
        }
    }
}
